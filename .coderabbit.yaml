# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

# CodeRabbit Configuration for MCP Gateway
# Documentation: https://docs.coderabbit.ai/getting-started/yaml-configuration
# Project: Self-hosted MCP aggregation layer with tool routing
# Tech Stack: Python (FastMCP), TypeScript (NPM client), Docker, Bash
# Cost Constraint: All features must be costless (self-hosted, open-source)

# General Settings
language: "en-US"
early_access: false
tone_instructions: "Be concise, technical, and focus on actionable feedback. Priority: security, performance, maintainability, cost-free solutions. Enforce: No paid APIs, stdlib-first approach."

# Code Reviews Configuration
reviews:
  # Assertive profile for strict quality gates
  profile: "assertive"

  # Block PR merge until issues resolved (100% quality requirement)
  request_changes_workflow: true

  # High-level summary of changes
  high_level_summary: true

  # No poems (keep professional)
  poem: false

  # Show review status
  review_status: true

  # Keep walkthrough expanded for transparency
  collapse_walkthrough: false

  # Auto-review settings
  auto_review:
    enabled: true
    drafts: false
    base_branches:
      - main
      - develop

  # Path-based instructions aligned with project structure
  path_instructions:
    # Python - Tool Router (core component)
    - path: "tool_router/**/*.py"
      instructions: |
        Critical component - tool routing logic.
        Requirements:
        - Type hints required (strict mypy compliance)
        - Google-style docstrings with Args, Returns, Raises
        - 100% test coverage for new code
        - Thread-safe implementations (check locks, race conditions)
        - No external paid APIs (cost constraint)
        - Prefer stdlib over dependencies
        - Error handling with descriptive messages
        - Performance: <100ms for cached operations

    # Python - Tests
    - path: "tool_router/tests/**/*.py"
      instructions: |
        Test quality requirements:
        - Use pytest fixtures for reusability
        - Parametrize tests for edge cases
        - Mock external dependencies (gateway, network)
        - Test both success and failure paths
        - Integration tests for end-to-end flows
        - Performance tests for latency-critical paths
        - 100% coverage for testable code

    # Shell Scripts - Gateway management
    - path: "scripts/**/*.sh"
      instructions: |
        Shell script requirements:
        - Shellcheck compliance (no warnings)
        - Proper error handling (set -euo pipefail)
        - POSIX compatibility where possible
        - Descriptive error messages
        - No hardcoded secrets
        - Use lib/ functions for reusability

    # Docker - Container definitions
    - path: "**/Dockerfile*"
      instructions: |
        Docker security and efficiency:
        - Multi-stage builds for smaller images
        - Non-root user execution
        - Minimal base images (alpine preferred)
        - No secrets in layers
        - Proper HEALTHCHECK directives
        - Layer caching optimization
        - Security scanning compliance

    # GitHub Actions - CI/CD
    - path: ".github/workflows/**/*.yml"
      instructions: |
        CI/CD requirements:
        - Use GitHub Actions free tier efficiently
        - No paid services or APIs
        - Secrets management via GitHub Secrets
        - Matrix builds for Python versions
        - Cache dependencies for speed
        - Fail fast on quality gates
        - Security scanning (gitleaks, trufflehog)

    # Documentation
    - path: "docs/**/*.md"
      instructions: |
        Documentation standards:
        - Clear, concise, with examples
        - Cross-link related docs
        - Keep CHANGELOG.md updated
        - Verify technical accuracy
        - Include troubleshooting sections
        - AI-agent friendly structure

    # Configuration files
    - path: "**/*.{yaml,yml,json}"
      instructions: |
        Configuration validation:
        - Valid syntax (yamllint, jsonlint)
        - No hardcoded secrets
        - Environment variable usage
        - Schema validation where applicable
        - Comments for complex settings

    # TypeScript - NPM Client
    - path: "src/**/*.ts"
      instructions: |
        TypeScript client requirements:
        - Strict mode enabled
        - No 'any' types (use unknown + guards)
        - NPX compatibility maintained
        - Error handling with proper types
        - No paid dependencies
        - ESM module format

  # Tools configuration - comprehensive linting
  tools:
    # Shell script linting
    shellcheck:
      enabled: true

    # Python linting (primary language)
    ruff:
      enabled: true

    # Markdown documentation
    markdownlint:
      enabled: true

    # YAML configuration
    yamllint:
      enabled: true

    # Docker best practices
    hadolint:
      enabled: true

    # Secret detection (critical for security)
    gitleaks:
      enabled: true

    # Additional secret scanning
    trufflehog:
      enabled: true

    # GitHub Actions validation
    actionlint:
      enabled: true

# Chat Configuration
chat:
  auto_reply: true

# Knowledge Base Configuration
knowledge_base:
  opt_out: false

  web_search:
    enabled: true

  code_guidelines:
    enabled: true

  learnings:
    scope: "auto"

  issues:
    scope: "auto"

  pull_requests:
    scope: "auto"

# Code Generation Configuration
code_generation:
  docstrings:
    language: "en-US"
    path_instructions:
      - path: "tool_router/**/*.py"
        instructions: |
          Generate Google-style docstrings:
          - Brief one-line summary
          - Detailed description if needed
          - Args: parameter descriptions with types
          - Returns: return value description with type
          - Raises: exceptions that may be raised
          - Example usage for complex functions

      - path: "scripts/**/*.sh"
        instructions: |
          Generate shell function documentation:
          - Brief description of purpose
          - Parameters: name and description
          - Returns: exit codes and meanings
          - Example: usage example

  unit_tests:
    path_instructions:
      - path: "tool_router/**/*.py"
        instructions: |
          Generate pytest tests following project standards:
          - Use fixtures for common setup
          - Parametrize for multiple test cases
          - Test success and failure paths
          - Mock external dependencies (HTTPGatewayClient, etc.)
          - Include edge cases (empty input, invalid types, etc.)
          - Performance assertions for critical paths
          - Thread-safety tests for concurrent code
          - 100% coverage requirement

# Issue Enrichment Configuration
issue_enrichment:
  auto_enrich:
    enabled: true
  planning:
    enabled: true
